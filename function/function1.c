#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

//함수 정의를 해줄땐 1. 함수의 기능에 맞는 이름인가? (함수명)
//2. 함수가 기능을 수행하는데 필요한 데이터는 무엇인가? (매개변수)
//3. 함수가 수행된 후의 결과는 무엇인가? (반환형)


//반환형은 int
int sum(int x, int y); //함수 원형(function prototype)
//먼저 함수 선언을 해준다. 
//함수명은 sum, 매개변수는 int x int y 매개변수의 이름은 x 그리고 y임, 반환형은 int
//매개변수 이름을 생략한 상태로써 int sum(int, int); 로도 가능


//함수 선언을 먼저 하는 이유는!!!? 함수선언은 컴파일러가 새로 만든 함수를 인식할 수 있도록 알리는 역할을 한다.
//함수 정의가 있는데 왜 함수 선언이 필요한가?
//함수 선언에서 반환값의 형태를 확인한다.
//컴파일러는 컴파일할 때 함수를 호출한 자리에 반환값과 같은 형태의 저장공간은 준비함
//정수를 반환하면 호출한 자리에 int형 공간을 확보한다. 
//따라서 즉 함수를 호출하기 전에 선언을 통해 반환형을 미리 컴파일러에 알릴 필요가 있다.

//따로 함수선언을 할 필요없이 main함수 앞에 함수 정의를 하면 된다. 어차피 프로그램은 항상 main함수부터 시작하기 때문.
//그러니 함수 선언이 없으면 함수 정의는 항상 함수 호출 이전에 있어야 한다.
//그런데 여러 함수 들이 main 함수 앞에 함수선언 없이 함수 정의만 하면 알아보기가 힘듬 함수 선언만 하고
//main함수 밑에 차례대로 만드는 것이 코드도 더 깔끔하고 그렇다.

//그리고 함수선언을 먼저하는 두번째 이유로 함수선언문에는 매개변수의 개수와 형태에 대한 정보가 있으므로
//호출할 때 정확한 값을 주는지 검사할 수 있다. 예를 들어 sum함수에 필요한 값이 정수 2개인데 인수로 실수를 주고
//호출하면 파일단계에서 확인하고 경고 메시지로 문제점을 알려줄 수 있기 때문임



int main(void) //main 함수
{
	int a = 10, b = 20;
	int result;  //두 정수를 더한 결과를 저장할 변수

	result = sum(a, b);  //sum 함수 호출
	//함수를 호출할 때에는 이름을 사용하며 함수에 필요한 데이터를 괄호 안에 넣어주는데
	//이를 '''인수(argument)''' 라고 한다. (여기서는 a, b가 인수)
	//sum함수를 호출하여 a와 b를 더하려면 함수명과 함께 괄호 안에 a, b를 넣고 호출한다.
	printf("result : %d\n", result);

	return 0;
}

int sum(int x, int y)  //함수 선언했던 sum 함수를 정의 함. (함수 원형)
{
	int temp; //두 정수의 합을 잠시 저장할 변수
	
	temp = x + y; //x와 y의 합을 temp에 보관

	return temp; //temp의 값을 반환
	//return은 함수의 실행결과를 돌려주는 '제어문'임.
}

//함수 function이란?? 기능을 수행하는 코드 단위!!
//지금까지 사용하는 main 함수가 대표적인 함수. printf, scanf도 함수
//printf나 scanf함수처럼 특정 기능을 미리 약속하고 프로그램에서 바로 사용할 수 있게 구현되어 있는 함수를
// '표준 라이브러리 함수' 라고 함.

//함수 정의 : 함수를 실제 코드로 만드는 것이고 기능을 구현함
//함수 호출 : 함수 호출을 해야지 함수를 사용할 수 있다.
//함수 선언 : 프로그램의 상단에서 어떤 함수를 사용할 것이라고 컴파일러에 정보를 주는 역할

