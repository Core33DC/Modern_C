//포인터와 간접 참조 연산자 *

//메모리의 주소는 필요할 때마다 계속 주소 연산을 줏행하는 것보다 한 번 구한 주소를 저장해서 사용하면 편리하다.
//즉 포인터가 바로 변수의 메모리 주소를 저장하는 변수임.
//따라서 주소를 저장할 포인터도 변수처럼 선언하고 사용함. 선언할때 변수 앞에 *만 붙여주면 됨.
#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
	int a;	//변수 선언
	int* da;	//포인터 선언
	//자료형 *변수명
	//포인터의 자료형은 변수의 자료형을 넣는다.

	da = &a;	//포인터 선언했던 da에 a의 '주소' 대입
	*da = 10;	//포인터로 변수 a에 '10' 대입
	//##여기서 중요한건 주소 대입은 앞에 간접참조연산자인 *를 붙이지 않고 변수 a에 값 대입하려면 간접참조연산자를 붙인다.##

	printf("포인터로 a값 출력 : %d\n", *da);
	printf("변수명으로 a값 출력 : %d\n", a);
	//즉 *da == a 로 같다.

	//*da는 변수 a의 쓰임과 마찬가지로 대입 연산자(=)의 왼쪽에 올 때는 da가 가리키는 변수의 저장공간 l-value으로 사용되고
	//오른쪽으로 올 때는 da가 가리키는 변수의 값 r-value으로 사용됨.

	return 0;
}

//만약 변수 a가 메모리 100번지부터 103번지까지(int니까 4바이트) 할당되었다면 주소 값 100이 da에 저장된다. 
//이제 포인터 da는 변수 a가 메모리 어디에 할당되었는지 그 위치를 기억하고 있다.
//이렇게 포인터가 어떤 변수의 주소를 저장한 경우 '가리킨다'라고 하고 둘의 관계를 da -> a 처럼 화살표로 간단히 표현한다.
//즉 x -> y로 표현하면 x는 y를 가리켜요 라고 뜻하고 x는 포인터고 변수 y의 주소를 저장하고 있다는 뜻이다.

//입력할때는 scanf함수는 입력할 변수가 메모리 어디에 할당되었는지 저장 공간의 위치를 알아야 한다.
//따라서 입력할 변수의 주소를 인수로 준다.
//포인터 da를 통해 변수 a에 입력할 때도 마찬가지임.* da는 a와 같으므로& a는&* pa와 같다.
//즉, 간접 참고 연산자로 da가 가리키는 변수를 구하고 다시 주소 연산자로 주소를 구한다.
//그런데 da가 a의 주소를 저장하고 있으니 바로 da를 사용해도 된다.
//
//&a로 변수 a의 저장 공간 찾을때
//scanf("%d", &a);
//
//pa로 변수 a의 저장 공간 찾기
//scanf("%d", da);

//p241 보면 da = &a;  ,  *da
