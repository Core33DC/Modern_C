//포인터에 const 사용

#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>

int main(void)
{
	int a = 10, b = 20;
	const int* pa = &a; //포인터 pa는 변수 a를 가리킨다. 포인터 pa를 선언할 때 const로 상수화 처리

	printf("변수 a의 값 : %d\n", *pa);  //포인터를 간접참조하여 a 출력
	
	pa = &b;	//포인터가 변수 b를 가리키게 한다.

	printf("변수 b의 값 : %d\n", *pa);	//포인터를 간접참조하여 b 출력
	//포인터 pa를 선언할때 const로 상수화 하였지만 출력 결과는 무관하게 변수 b의 주소를 저장하고 그 값을 간접 참조하여 출력하고 있음.
	//앞서 포인터에 사용된 const의 의미는 바로 'pa가 가리키는 변수 a'는 'pa를 간접 참조하여 바꿀 수 없다.'
	//그래서 만약 밑에 23행에서 *pa=20;과 같이 pa를 통해 a값을 바꾸고자 한다면 에러메세지가 나옴.


	pa = &a;	//포인터가 다시 변수 a를 가리킨다.
	a = 20;	//a를 직접 참조하여 값을 바꾼다.
	//*pa = 20; 이렇게로는 안된다는 뜻이다.
	//이렇게 한다면 에러메시지로 l-value가 const 개체를 지정한다고 뜸.
	
	printf("변수 a의 값 : %d\n", *pa);	//포인터로 간접 참조하여 '바뀐 값' 출력

	return 0;
}

//변수 a는 어디까지나 포인터를 통해서만 바꿀 수 없고 변수 a 자체를 사용하면 얼마든지 바꿀 수 있는데 왜!!!!! const를 썼을까??
//그 이유로는 포인터에 const를 사용하는 대표적인 예는 문자열 상수를 인수로 받는 함수이다.
//문자열 상수는 값이 바뀌면 안 되는 저장 공간이므로 함수의 매개변수를 통해서 값을 바꿀 수 없도록 매개변수로 선언된 포인터에 const를 사용한다.
//지금은 헷갈리지만 문자열과 포인터의 관계를 공부하면 더 이해하기 쉬워짐

//###!!!!
//아마 포인터 pa가 할당된 영역을 바꾸면은 안되나보다... 아.. 시벌 저장되어있던 영역이 바뀌면 쓰레기 값이 나오던가 메모리 누수가 일어날듯???